<!-- Page Loading Overlay -->
<div id="loading-overlay" style="position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #0f0f0f; z-index: 9999; display: flex; align-items: center; justify-content: center; transition: opacity 0.5s ease;">
    <div style="text-align: center; color: #10b981;">
        <div style="width: 40px; height: 40px; border: 3px solid rgba(16, 185, 129, 0.3); border-top: 3px solid #10b981; border-radius: 50%; animation: spin 1s linear infinite; margin: 0 auto 1rem;"></div>
        <p>Loading Prompt Enhancer...</p>
    </div>
</div>

<style>
    @keyframes spin {
        0% { transform: rotate(0deg); }
        100% { transform: rotate(360deg); }
    }
</style>

<script>
    // Hide loading overlay when page is fully loaded
    window.addEventListener('load', () => {
        const overlay = document.getElementById('loading-overlay');
        overlay.style.opacity = '0';
        setTimeout(() => {
            overlay.style.display = 'none';
        }, 500);
    });
</script>

<!-- Modular JavaScript -->
<script>
    // Mark that we're loading modules
    window.moduleLoading = true;
</script>

<script type="module">
    // Import and initialize the main app
    try {
        const module = await import('../js/index.js');
        console.log('ðŸ“¦ Module loaded:', module);
        
        if (module.PromptEnhancerApp) {
            const app = new module.PromptEnhancerApp();
            await app.init();
            console.log('âœ… App initialized successfully');
        } else {
            throw new Error('PromptEnhancerApp not found in module');
        }
    } catch (error) {
        console.error('âŒ Failed to load main module:', error);
        console.log('ðŸ”„ Loading fallback scripts...');
        
        // Initialize essential functionality immediately
        initEssentialFunctionality();
    }
    
    function initEssentialFunctionality() {
        console.log('ðŸš€ Initializing essential functionality...');
        
        // Wait for DOM to be ready
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => {
                initAllFeatures();
            });
        } else {
            initAllFeatures();
        }
    }
    
    function initAllFeatures() {
    function initAllFeatures() {
        // Global scroll function
        window.scrollToWaitlist = function() {
            const waitlistSection = document.getElementById('waitlist-section');
            if (waitlistSection) {
                waitlistSection.scrollIntoView({ behavior: 'smooth' });
            }
        };
        
        // Initialize typing animation
        initTypingAnimation();
        
        // Initialize platform scrolling
        initPlatformScrolling();
        
        // Initialize scroll effects
        initScrollEffects();
        
        // Initialize basic interactions
        initBasicInteractions();
    }
    
    // Platform scrolling functionality
    function initPlatformScrolling() {
        console.log('ðŸ–±ï¸ Initializing platform scrolling...');
        
        const platformsContainer = document.querySelector('.platforms-scroll');
        if (!platformsContainer) {
            console.log('âš ï¸ Platforms container not found');
            return;
        }
        
        let isDown = false;
        let startX;
        let scrollLeft;
        
        // Start auto-scroll
        let autoScrollDirection = 1;
        const autoScrollSpeed = 0.5;
        
        function autoScroll() {
            if (!isDown) {
                platformsContainer.scrollLeft += autoScrollSpeed * autoScrollDirection;
                
                // Reverse direction at edges
                if (platformsContainer.scrollLeft >= platformsContainer.scrollWidth - platformsContainer.clientWidth) {
                    autoScrollDirection = -1;
                } else if (platformsContainer.scrollLeft <= 0) {
                    autoScrollDirection = 1;
                }
            }
            requestAnimationFrame(autoScroll);
        }
        
        autoScroll();
        
        // Mouse drag controls
        platformsContainer.addEventListener('mousedown', (e) => {
            isDown = true;
            startX = e.pageX - platformsContainer.offsetLeft;
            scrollLeft = platformsContainer.scrollLeft;
            platformsContainer.style.cursor = 'grabbing';
        });
        
        platformsContainer.addEventListener('mouseleave', () => {
            isDown = false;
            platformsContainer.style.cursor = 'grab';
        });
        
        platformsContainer.addEventListener('mouseup', () => {
            isDown = false;
            platformsContainer.style.cursor = 'grab';
        });
        
        platformsContainer.addEventListener('mousemove', (e) => {
            if (!isDown) return;
            e.preventDefault();
            const x = e.pageX - platformsContainer.offsetLeft;
            const walk = (x - startX) * 2;
            platformsContainer.scrollLeft = scrollLeft - walk;
        });
        
        console.log('âœ… Platform scrolling initialized');
    }
    
    // Fallback typing animation
    function initTypingAnimation() {
        const typingText = document.getElementById('typingText');
        if (!typingText) {
            console.log('âš ï¸ Typing text element not found');
            return;
        }
        
        const phrases = [
            '"help me code"',
            '"write an email"',
            '"explain this concept"',
            '"create content"',
            '"solve this problem"',
            '"analyze data"'
        ];
        
        let currentPhrase = 0;
        let currentChar = 0;
        let isDeleting = false;
        
        function typeEffect() {
            const current = phrases[currentPhrase];
            
            if (isDeleting) {
                typingText.textContent = current.substring(0, currentChar - 1);
                currentChar--;
                
                if (currentChar === 0) {
                    isDeleting = false;
                    currentPhrase = (currentPhrase + 1) % phrases.length;
                    setTimeout(typeEffect, 500);
                    return;
                }
            } else {
                typingText.textContent = current.substring(0, currentChar + 1);
                currentChar++;
                
                if (currentChar === current.length) {
                    isDeleting = true;
                    setTimeout(typeEffect, 2000);
                    return;
                }
            }
            
            setTimeout(typeEffect, isDeleting ? 50 : 100);
        }
        
        console.log('ðŸŽ­ Starting typing animation');
        typeEffect();
    }
    
    // Fallback scroll effects and platform scrolling
    function initScrollEffects() {
        console.log('ðŸ“œ Initializing scroll effects');
        
        // Platform scrolling drag functionality
        const platformsContainer = document.querySelector('.platforms-scroll');
        if (platformsContainer) {
            let isDown = false;
            let startX;
            let scrollLeft;
            
            platformsContainer.addEventListener('mousedown', (e) => {
                isDown = true;
                platformsContainer.classList.add('dragging');
                startX = e.pageX - platformsContainer.offsetLeft;
                scrollLeft = platformsContainer.scrollLeft;
                platformsContainer.style.animationPlayState = 'paused';
            });
            
            platformsContainer.addEventListener('mouseleave', () => {
                isDown = false;
                platformsContainer.classList.remove('dragging');
                platformsContainer.style.animationPlayState = 'running';
            });
            
            platformsContainer.addEventListener('mouseup', () => {
                isDown = false;
                platformsContainer.classList.remove('dragging');
                platformsContainer.style.animationPlayState = 'running';
            });
            
            platformsContainer.addEventListener('mousemove', (e) => {
                if (!isDown) return;
                e.preventDefault();
                const x = e.pageX - platformsContainer.offsetLeft;
                const walk = (x - startX) * 2;
                platformsContainer.scrollLeft = scrollLeft - walk;
            });
            
            console.log('ðŸ–±ï¸ Platform scrolling initialized');
        }
        
        // Add intersection observer for animations
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('animate-in');
                }
            });
        }, { threshold: 0.1 });
        
        // Observe elements that need animation
        setTimeout(() => {
            document.querySelectorAll('.stat-card, .feature-card, .testimonial-card, .benefit-card').forEach(el => {
                observer.observe(el);
            });
        }, 100);
    }
    
    // Basic interactions
    function initBasicInteractions() {
        console.log('ðŸŽ® Initializing basic interactions');
        
        // FAQ toggles
        document.querySelectorAll('.faq-question').forEach(question => {
            question.addEventListener('click', () => {
                const faqItem = question.parentElement;
                const isOpen = faqItem.classList.contains('open');
                
                // Close all other FAQs
                document.querySelectorAll('.faq-item').forEach(item => {
                    item.classList.remove('open');
                });
                
                // Toggle current FAQ
                if (!isOpen) {
                    faqItem.classList.add('open');
                }
            });
        });
        
        // Form handlers
        const waitlistForm = document.getElementById('waitlist-form');
        if (waitlistForm) {
            waitlistForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const email = e.target.querySelector('input[type="email"]').value;
                console.log('ðŸ“§ Waitlist signup:', email);
                // Add your form submission logic here
                alert('Thanks for joining the waitlist! ðŸŽ‰');
            });
        }
        
        // Smooth scrolling for anchor links
        document.querySelectorAll('a[href^="#"]').forEach(link => {
            link.addEventListener('click', (e) => {
                e.preventDefault();
                const targetId = link.getAttribute('href').substring(1);
                const targetElement = document.getElementById(targetId);
                if (targetElement) {
                    targetElement.scrollIntoView({ behavior: 'smooth' });
                }
            });
        });
    }
</script>

<!-- Global functions for compatibility -->
<script>
    // Global functions that components might need
    window.scrollToWaitlist = function() {
        const waitlistSection = document.getElementById('waitlist-section');
        if (waitlistSection) {
            waitlistSection.scrollIntoView({ behavior: 'smooth' });
        }
    };
    
    window.scrollToSection = function(sectionId) {
        const section = document.getElementById(sectionId);
        if (section) {
            section.scrollIntoView({ behavior: 'smooth' });
        }
    };
    
    // Initialize when components are ready
    document.addEventListener('componentsReady', () => {
        console.log('ðŸŽ‰ Components ready, initializing interactions...');
        
        // Initialize FAQ toggles
        document.querySelectorAll('.faq-question').forEach(question => {
            question.addEventListener('click', () => {
                const faqItem = question.parentElement;
                const isOpen = faqItem.classList.contains('open');
                
                // Close all other FAQs
                document.querySelectorAll('.faq-item').forEach(item => {
                    item.classList.remove('open');
                });
                
                // Toggle current FAQ
                if (!isOpen) {
                    faqItem.classList.add('open');
                }
            });
        });
        
        // Initialize form handlers
        const waitlistForm = document.getElementById('waitlist-form');
        if (waitlistForm) {
            waitlistForm.addEventListener('submit', (e) => {
                e.preventDefault();
                const email = e.target.querySelector('input[type="email"]').value;
                console.log('Waitlist signup:', email);
                // Add your form submission logic here
                alert('Thanks for joining the waitlist!');
            });
        }
    });
</script>

<!-- Animation Initialization -->
<script>
    // Initialize animations when components are loaded
    document.addEventListener('componentsReady', () => {
        console.log('ðŸŽ¬ Initializing animations...');
        
        // Add intersection observer for animations
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    entry.target.classList.add('animate-in');
                    console.log('ðŸŽ­ Animating:', entry.target.className);
                }
            });
        }, { 
            threshold: 0.1,
            rootMargin: '0px 0px -50px 0px'
        });
        
        // Wait for all components to load, then observe elements
        setTimeout(() => {
            const elementsToAnimate = document.querySelectorAll(
                '.benefit-card, .stat-card, .testimonial-card, .faq-item, .step, .pricing-card, .achievement-item, .comparison-card'
            );
            
            elementsToAnimate.forEach(el => {
                observer.observe(el);
            });
            
            console.log(`ðŸŽ¬ Initialized animations for ${elementsToAnimate.length} elements`);
            
            // Trigger animations for elements already in view
            elementsToAnimate.forEach(el => {
                const rect = el.getBoundingClientRect();
                if (rect.top < window.innerHeight && rect.bottom > 0) {
                    el.classList.add('animate-in');
                }
            });
        }, 1000);
    });
</script>
