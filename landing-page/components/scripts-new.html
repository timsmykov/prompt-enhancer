<!-- Page Loading Overlay -->
<div id="loading-overlay" class="loading-overlay">
    <div class="loading-content">
        <div class="loading-spinner"></div>
        <p>Loading Prompt Enhancer...</p>
    </div>
</div>
<script src="js/page-init.js" defer></script>

<!-- Comprehensive Initialization System -->
<script>
    console.log('🚀 Starting Prompt Enhancer initialization...');
    
    // Hide loading overlay when page is fully loaded
    window.addEventListener('load', () => {
        const overlay = document.getElementById('loading-overlay');
        if (overlay) {
            overlay.style.opacity = '0';
            setTimeout(() => {
                overlay.style.display = 'none';
            }, 500);
        }
    });

    // Main initialization system
    class PromptEnhancerInit {
        constructor() {
            this.initialized = false;
            this.features = {
                typing: false,
                platforms: false,
                animations: false,
                faq: false,
                forms: false,
                scrolling: false
            };
        }

        async init() {
            if (this.initialized) return;
            
            console.log('🎯 Initializing Prompt Enhancer features...');
            
            // Wait for components to be ready
            await this.waitForComponents();
            
            // Initialize all features
            await this.initializeAllFeatures();
            
            this.initialized = true;
            console.log('✅ All features initialized successfully!');
        }

        waitForComponents() {
            return new Promise((resolve) => {
                // Check if components are already loaded
                if (document.querySelector('.hero') && document.querySelector('.faq')) {
                    resolve();
                    return;
                }
                
                // Wait for componentsReady event
                document.addEventListener('componentsReady', () => {
                    setTimeout(resolve, 500); // Give components time to settle
                });
            });
        }

        async initializeAllFeatures() {
            // Global navigation functions
            this.setupGlobalFunctions();
            
            // Initialize features in order
            await this.initTypingAnimation();
            await this.initPlatformScrolling();
            await this.initAnimations();
            await this.initFAQ();
            await this.initForms();
            await this.initSmoothScrolling();
            
            console.log('🎉 Feature initialization complete:', this.features);
        }

        setupGlobalFunctions() {
            // Global scroll functions for buttons
            window.scrollToWaitlist = () => {
                const waitlistSection = document.getElementById('waitlist-section') || document.getElementById('waitlist');
                if (waitlistSection) {
                    waitlistSection.scrollIntoView({ behavior: 'smooth' });
                }
            };
            
            window.scrollToSection = (sectionId) => {
                const section = document.getElementById(sectionId);
                if (section) {
                    section.scrollIntoView({ behavior: 'smooth' });
                }
            };
            
            console.log('🌐 Global functions set up');
        }

        async initTypingAnimation() {
            try {
                const typingText = document.getElementById('typingText');
                if (!typingText) {
                    console.log('⚠️ Typing text element not found');
                    return;
                }

                const phrases = [
                    '"help me code"',
                    '"write an email"',
                    '"explain this concept"',
                    '"create content"',
                    '"solve this problem"',
                    '"analyze data"'
                ];

                let currentPhrase = 0;
                let currentChar = 0;
                let isDeleting = false;

                const typeEffect = () => {
                    const current = phrases[currentPhrase];

                    if (isDeleting) {
                        typingText.textContent = current.substring(0, currentChar - 1);
                        currentChar--;

                        if (currentChar === 0) {
                            isDeleting = false;
                            currentPhrase = (currentPhrase + 1) % phrases.length;
                            setTimeout(typeEffect, 500);
                            return;
                        }
                    } else {
                        typingText.textContent = current.substring(0, currentChar + 1);
                        currentChar++;

                        if (currentChar === current.length) {
                            isDeleting = true;
                            setTimeout(typeEffect, 2000);
                            return;
                        }
                    }

                    setTimeout(typeEffect, isDeleting ? 50 : 100);
                };

                typeEffect();
                this.features.typing = true;
                console.log('✅ Typing animation initialized');
            } catch (error) {
                console.error('❌ Typing animation error:', error);
            }
        }

        async initPlatformScrolling() {
            try {
                const platformsContainer = document.querySelector('.platforms-scroll');
                if (!platformsContainer) {
                    console.log('⚠️ Platforms container not found');
                    return;
                }

                let isDown = false;
                let startX;
                let scrollLeft;

                // Auto-scroll functionality
                let autoScrollDirection = 1;
                const autoScrollSpeed = 0.5;

                const autoScroll = () => {
                    if (!isDown && platformsContainer) {
                        platformsContainer.scrollLeft += autoScrollSpeed * autoScrollDirection;

                        // Reverse direction at edges
                        if (platformsContainer.scrollLeft >= platformsContainer.scrollWidth - platformsContainer.clientWidth) {
                            autoScrollDirection = -1;
                        } else if (platformsContainer.scrollLeft <= 0) {
                            autoScrollDirection = 1;
                        }
                    }
                    requestAnimationFrame(autoScroll);
                };

                autoScroll();

                // Mouse drag controls
                platformsContainer.addEventListener('mousedown', (e) => {
                    isDown = true;
                    startX = e.pageX - platformsContainer.offsetLeft;
                    scrollLeft = platformsContainer.scrollLeft;
                    platformsContainer.style.cursor = 'grabbing';
                });

                platformsContainer.addEventListener('mouseleave', () => {
                    isDown = false;
                    platformsContainer.style.cursor = 'grab';
                });

                platformsContainer.addEventListener('mouseup', () => {
                    isDown = false;
                    platformsContainer.style.cursor = 'grab';
                });

                platformsContainer.addEventListener('mousemove', (e) => {
                    if (!isDown) return;
                    e.preventDefault();
                    const x = e.pageX - platformsContainer.offsetLeft;
                    const walk = (x - startX) * 2;
                    platformsContainer.scrollLeft = scrollLeft - walk;
                });

                this.features.platforms = true;
                console.log('✅ Platform scrolling initialized');
            } catch (error) {
                console.error('❌ Platform scrolling error:', error);
            }
        }

        async initAnimations() {
            try {
                const observer = new IntersectionObserver((entries) => {
                    entries.forEach(entry => {
                        if (entry.isIntersecting) {
                            entry.target.classList.add('animate-in');
                        }
                    });
                }, { 
                    threshold: 0.1,
                    rootMargin: '0px 0px -50px 0px'
                });

                // Find all elements that need animation
                const elementsToAnimate = document.querySelectorAll(
                    '.benefit-card, .stat-card, .testimonial-card, .faq-item, .step, .pricing-card, .achievement-item, .comparison-card'
                );

                elementsToAnimate.forEach(el => {
                    observer.observe(el);
                });

                // Trigger animations for elements already in view
                elementsToAnimate.forEach(el => {
                    const rect = el.getBoundingClientRect();
                    if (rect.top < window.innerHeight && rect.bottom > 0) {
                        el.classList.add('animate-in');
                    }
                });

                this.features.animations = true;
                console.log(`✅ Animations initialized for ${elementsToAnimate.length} elements`);
            } catch (error) {
                console.error('❌ Animations error:', error);
            }
        }

        async initFAQ() {
            try {
                const faqQuestions = document.querySelectorAll('.faq-question');
                
                faqQuestions.forEach(question => {
                    if (!question.dataset.initialized) {
                        question.addEventListener('click', () => {
                            const faqItem = question.parentElement;
                            const isOpen = faqItem.classList.contains('open');

                            // Close all other FAQs
                            document.querySelectorAll('.faq-item').forEach(item => {
                                item.classList.remove('open');
                            });

                            // Toggle current FAQ
                            if (!isOpen) {
                                faqItem.classList.add('open');
                            }
                        });
                        question.dataset.initialized = 'true';
                    }
                });

                this.features.faq = true;
                console.log(`✅ FAQ initialized for ${faqQuestions.length} questions`);
            } catch (error) {
                console.error('❌ FAQ error:', error);
            }
        }

        async initForms() {
            try {
                const waitlistForm = document.getElementById('waitlist-form');
                if (waitlistForm && !waitlistForm.dataset.initialized) {
                    waitlistForm.addEventListener('submit', (e) => {
                        e.preventDefault();
                        
                        const formData = new FormData(waitlistForm);
                        const name = formData.get('name');
                        const email = formData.get('email');
                        
                        console.log('📧 Waitlist signup:', { name, email });

                        // Show success message
                        const successDiv = document.getElementById('form-success');
                        if (successDiv) {
                            successDiv.style.display = 'block';
                            waitlistForm.style.display = 'none';
                        } else {
                            alert('Thanks for joining the waitlist! 🎉');
                        }
                    });
                    waitlistForm.dataset.initialized = 'true';
                }

                this.features.forms = true;
                console.log('✅ Forms initialized');
            } catch (error) {
                console.error('❌ Forms error:', error);
            }
        }

        async initSmoothScrolling() {
            try {
                document.querySelectorAll('a[href^="#"]').forEach(link => {
                    if (!link.dataset.initialized) {
                        link.addEventListener('click', (e) => {
                            e.preventDefault();
                            const targetId = link.getAttribute('href').substring(1);
                            const targetElement = document.getElementById(targetId) || document.getElementById(targetId + '-section');
                            if (targetElement) {
                                targetElement.scrollIntoView({ behavior: 'smooth' });
                            }
                        });
                        link.dataset.initialized = 'true';
                    }
                });

                this.features.scrolling = true;
                console.log('✅ Smooth scrolling initialized');
            } catch (error) {
                console.error('❌ Smooth scrolling error:', error);
            }
        }
    }

    // Initialize everything when components are ready
    const app = new PromptEnhancerInit();
    
    if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', () => {
            setTimeout(() => app.init(), 100);
        });
    } else {
        setTimeout(() => app.init(), 100);
    }

    // Also listen for componentsReady event
    document.addEventListener('componentsReady', () => {
        setTimeout(() => app.init(), 200);
    });
</script>

<!-- Module Loading Fallback -->
<script type="module">
    try {
        const module = await import('../js/index.js');
        console.log('📦 Module loaded successfully:', module);
        
        if (module.PromptEnhancerApp) {
            const moduleApp = new module.PromptEnhancerApp();
            await moduleApp.init();
            console.log('✅ Module app initialized');
        }
    } catch (error) {
        console.log('ℹ️ Module loading failed, using fallback system:', error.message);
        // The fallback system above will handle everything
    }
</script>
